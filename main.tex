\documentclass[xcolor={dvipsnames},aspectratio=169,10pt]{beamer}

\input{preamble.tex}
\addbibresource{ref.bib}

\title{Authenticated Query Processing in the Cloud}
\author{XU Cheng}
\institute{Supervisor: Prof.~XU Jianliang}
\date{January 31, 2019}
\titlegraphic{\hfill\resizebox{!}{0.7cm}{\input{figs/group-logo.tex}}}

\begin{document}

\maketitle%

\begin{frame}{Contents}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}

\section{Introduction}

\begin{frame}{Background}
  \begin{itemize}[<+->]
    \item \alert{\emph{Data-as-a-Service} (DaaS)} and \alert{cloud computing} are gaining popularity for big data analytics
      \begin{figure}
        \input{figs/model.tex}
        \caption{System Model}
      \end{figure}
    \item \textcolor{Red}{Security Threats}: SP cannot be fully trusted $\Rightarrow$ Query result integrity not guaranteed
    \item \textcolor{Green}{Solution}:
      \begin{itemize}[<1->]
        \item DO signs a well-designed \alert{\emph{authenticated data structure} (ADS)}
        \item SP constructs a cryptographic proof a.k.a.\ \alert{\emph{verifciation object} (VO)}
        \item Clients verify the correctness of the results based on VO
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Related Works}
  \begin{columns}
    \begin{column}{0.8\linewidth}
      \begin{itemize}[<+->]
        \item There are two approaches to support authenticated query processing
        \item \alert{ADS-based Solutions}
          \begin{itemize}[<1->]
            \item Designed specifically based on the computation task
            \item \makebox[.35\linewidth][l]{\textcolor{Green}{Pros}: efficient}
              \textcolor{Red}{Cons}: only work for the specific queries
            \item \textcolor{Violet}{Examples}:
              \parbox[t]{\linewidth}{%
                \strut%
                signature chaining~\cite{10.1109/ICDE.2004.1320027}, Merkle hash tree~\cite{10.1007/0-387-34805-0_21}, \\ set accumulator~\cite{10.1145/2660267.2660373}, etc.%
                \strut%
              }%
          \end{itemize}
        \item \alert{General-Purpose Solutions}
          \begin{itemize}[<1->]
            \item Modeling computation task as boolean or arithmetic circuit
            \item \makebox[.35\linewidth][l]{\textcolor{Green}{Pros}: expressive}
              \textcolor{Red}{Cons}: high setup \& proving cost
            \item \textcolor{Violet}{Examples}: zkSNARKs~\cite{10.1109/sp.2013.47}, RAM-based VC~\cite{10.1145/2517349.2522733}, etc.
          \end{itemize}
        \item We focus on \alert{ADS-based solutions} in this dissertation
      \end{itemize}
    \end{column}%
    \begin{column}{0.2\linewidth}
      \begin{figure}
        \onslide<2->{%
          \resizebox{\linewidth}{!}{\input{figs/sig-chain.tex}}
          \caption{Signature Chaining}
          \resizebox{\linewidth}{!}{\input{figs/mht.tex}}
          \caption{Merkle Hash Tree}
          \onslide<3->{%
            \resizebox{\linewidth}{!}{\input{figs/zksnarks.tex}}
            \caption{zkSNARKs}
          }
        }
      \end{figure}%
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Limitations of the Existing Works}
  \begin{itemize}[<+->]
    \item However, the prior works have only considered \alert{limited query types}
    \item They fail to consider:
      \begin{itemize}[<+- | alert@+>]
        \item Aggregate queries over set-valued data for data analytics
        \item Enforcing fine-grained access control
        \item Query processing in distributed settings
      \end{itemize}
  \end{itemize}

  \begin{columns}[b]
    \begin{column}{0.33\linewidth}
      \begin{figure}
        \onslide<3->{%
          \resizebox{\linewidth}{!}{\input{figs/analytics.tex}}
          \caption{Analytical Queries}
        }
      \end{figure}
    \end{column}
    \begin{column}{0.33\linewidth}
      \begin{figure}
        \onslide<4->{%
          \resizebox{\linewidth}{!}{\input{figs/access-control.tex}}
          \caption{Access Control}
        }
      \end{figure}
    \end{column}
    \begin{column}{0.33\linewidth}
      \begin{figure}
        \onslide<5->{%
          \resizebox{\linewidth}{!}{\input{figs/distributed.tex}}
          \caption{Distributed Query Processing}
        }
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\section{Authenticating Aggregate Queries over Set-Valued Data}

\subsection{Problem Formulation}

\begin{frame}[fragile]{Example of Aggregate Queries over Set-Valued Data}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \setbeamercovered{transparent}
      \begin{table}
        \resizebox{\linewidth}{!}{%
          \begin{tabular}{ccl}
            \toprule
            \textbf{PID} & \textbf{ZIP} & \multicolumn{1}{c}{\textbf{Mut-Genes}}\\
            \midrule
            \onslide<1,2,3>{P1&95014&\alert<2>{A-C130R}, P-I696M} \\
            \onslide<1,3,4>{P2&20482&H-C282Y, \alert<4>{P-P12A}, \alert<3,4>{R-G1886S}} \\
            \onslide<1,2,3>{P3&95014&\alert<2>{A-C130R}, U-G71R, W-R611H} \\
            \onslide<1,3>{P4&01720&A-V2050L, H-C282Y, M-R52C, U-G71R} \\
            \onslide<1,3,4>{P5&20134&A-C130R, \alert<4>{P-P12A}, \alert<3,4>{R-G1886S}, S-E366K} \\
            \onslide<1,3>{P6&17868& C-R102G, \alert<3>{R-G1886S}} \\
            \onslide<1,3>{P7&55410&C-R102G, C-Q1334H, S-E288V} \\
            \onslide<1,3,4>{P8&20852&C-R102G, \alert<4>{P-P12A}, \alert<3,4>{R-G1886S}, K-T220M} \\
            \bottomrule
          \end{tabular}
        }
        \caption{Set-Valued Genome Dataset~\cite{pgp}}
      \end{table}
    \end{column}%
    \begin{column}{.5\linewidth}
      \begin{itemize}[<+(1)->]% chktex 36
        \item \textbf{Q1}: Find the most common gene in the district of Cupertino, CA (ZIP\@: 95014) \\
          \textcolor{Violet}{\emph{Answer:} \{`A-C130R'\}}
        \item \textbf{Q2}: Count the number of participants who carry the gene `R-G1886S' \\
          \textcolor{Violet}{\emph{Answer:} 4}
        \item \textbf{Q3}: Find the most frequent genes with supports $\ge$ 3 in ZIPs 20*** \\
          \textcolor{Violet}{\emph{Answer:} \{`P-P12A', `R-G1886S'\}}
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Problem Definition}
  \begin{itemize}[<+->]
    \item \textbf{Dataset} $\mathbb{D} = \{o_1, o_2, \dotsc, o_n\}$
      \begin{itemize}[<.->]
        \item $o_i = \langle A_i, X_i \rangle$.
        \item $A_i$ is a set of \textcolor{Green}{non-sensitive} attributes
        \item $X_i$ is a \textcolor{Red}{sensitive} multiset of \emph{features}
      \end{itemize}
    \item \textbf{Aggregate Query} $Q = (q, \{x_i\}, [\alpha, \beta])$
      \begin{itemize}[<.->]
        \item $q$ is an aggregate operator, i.e., \emph{max/min}, \emph{count}, \emph{sum}, \emph{top-$k$}, and \emph{frequent feature query (FFQ)}
        \item $\{x_i\}$ is the queried feature specified for \emph{count} and \emph{sum}
        \item $[\alpha, \beta]$ specifies the selection range over the \textcolor{Green}{non-sensitive} attributes
      \end{itemize}
    \item \textbf{Threat Model}
      \begin{itemize}[<.->]
        \item \alert{Integrity}: SP should prove the \emph{soundness} and \emph{completeness} of the results
        \item \alert{Confidentiality}: Clients should not infer any \emph{sensitive source data}
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Preliminaries}

\begin{frame}{Preliminaries}
  \begin{definition}<+->[Bilinear-Map (BM) Accumulator]
    Let $g$ be the group generator of a cyclic multiplicative group $\mathbb{G}$ and $s$ be a \textcolor{Red}{private value of DO}. The accumulator maps a multiset $X = \{ x_1, x_2, \dotsc, x_m \}$ to a single value in $\mathbb{G}$:
    \begin{align*}
      acc(X) = g^{P(X)} = g^{\prod_{x_i \in X}(x_i + s)}
    \end{align*}
    Without knowing $s$, one can still compute an $acc(\cdot)$ value by giving $g^s, g^{s^2}, \dotsc$
  \end{definition}
  \begin{example}<.->
    $X = \{ 1, 1, 2 \}$, $acc(X) = g^{{(1+s)}^2(2+s)} = g^{s^3+4 s^2+5 s+2} = g^{s^3} \cdot {(g^{s^2})}^4 \cdot {(g^s)}^5 \cdot g^2$
  \end{example}
  \begin{definition}<+->[Randomized BM Accumulator]
    BM accumulator is \alert{deterministic} for \emph{a fixed multiset}. As such, an adversary can tell in high confidence that two multisets are the same. We can randomize BM accumulator as following:
    \begin{align*}
      acc(X) = g^{P(X) \cdot r_X} = g^{r_X\prod_{x_i \in X}(x_i + s)}
    \end{align*}
    $r_X$ is a random value \textcolor{Red}{hidden from Clients} but \textcolor{Green}{disclosed to SP}.
  \end{definition}
\end{frame}

\begin{frame}{Preliminaries}
  \begin{definition}[Cryptographic Hash Function]
    A cryptographic hash function $H(\cdot)$ accepts an arbitrary-length string as its input and returns a fixed-length bit string such that it is computationally infeasible to find $m_1 \neq m_2$ and $H(m_1) = H(m_2)$.
  \end{definition}
  \begin{definition}[Bilinear Pairing]
    Let $\mathbb{G}, \mathbb{G}_T$ be two cyclic multiplicative groups of order $p$.
    A pairing is a map $e: \mathbb{G} \times \mathbb{G} \to \mathbb{G}_T$, which satisfies:
    \begin{itemize}
      \item \textbf{Bilinearity}: $e(u^a,v^b) = {e(u,v)}^{ab}$, $\forall u, v \in \mathbb{G}$
      \item \textbf{Non-degeneracy}: $e(g,g) \ne 1$
      \item \textbf{Computability}: Given $u, v \in \mathbb{G}$, it is easy to compute $e(u, v)$
    \end{itemize}
  \end{definition}
\end{frame}

\subsection{PA$^2$ Authentication Framework}

\begin{frame}[fragile]{PA$^2$ Authentication Framework Overview}
  \begin{figure}
    \onslide<+->{%
      \resizebox{.8\linewidth}{!}{%
        \begin{tikzpicture}
          \node[anchor=south west,inner sep=0] (A) at (0,0)
            {\includegraphics[width=\linewidth]{figs/aggregate-queries/overview.pdf}};
          \coordinate (multiset1) at (8.6,2.2);
          \coordinate (multiset2) at (11.9,3.45);
          \coordinate (aggregate1) at (9,0.1);
          \coordinate (aggregate2) at (11.7,1.55);
          \coordinate (select1) at (4.8,0.1);
          \coordinate (select2) at (7.57,3.45);
          \draw<2>[Red,ultra thick] (multiset1) rectangle (multiset2);
          \fill<2>[draw=none,fill=black,fill opacity=0.3,even odd rule]
            (A.south west) rectangle (A.north east)
            (multiset1) rectangle (multiset2);
          \draw<3>[Red,ultra thick] (aggregate1) rectangle (aggregate2);
          \fill<3>[draw=none,fill=black,fill opacity=0.3,even odd rule]
            (A.south west) rectangle (A.north east)
            (aggregate1) rectangle (aggregate2);
          \draw<4>[Red,ultra thick] (select1) rectangle (select2);
          \fill<4>[draw=none,fill=black,fill opacity=0.3,even odd rule]
            (A.south west) rectangle (A.north east)
            (select1) rectangle (select2);
        \end{tikzpicture}
      }
      \caption{Privacy-Preserving Authentication Framework for Aggregate Queries}
    }
  \end{figure}
  \begin{itemize}[<+- | alert@+>]
    \item PA$^2$ Protocols on Multiset Operations
    \item PA$^2$ Algorithms on Aggregate Queries
    \item PA$^2$ on Candidate Object Selection
  \end{itemize}
\end{frame}

\subsubsection{PA$^2$ Protocols on Multiset Operations}

\begin{frame}{PA$^2$ Protocols on Multiset Operations --- Subset}
  \begin{block}{$sub(X_1, X_2)$: returns $acc$ value of $X_1 - X_2$ iff $X_2 \subseteq X_1$}
    \begin{itemize}
      \item DO prepares $acc(X_1)$, $acc(X_2)$
      \item SP computes ${acc(X_1 - X_2)}^* = g^{r_{X_1}/r_{X_2} \prod_{x \in (X_1 - X_2)} (x+s)}$
      \item Client verifies $e(acc(X_2), {acc(X_1 - X_2)}^*) \stackrel{?}{=} e(acc(X_1), g)$
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item $X_1 = \{ 1, 1, 2 \}$, $X_2 = \{ 1, 2 \}$
      \item $acc(X_1) = g^{r_{X_1}{(1+s)}^2(2+s)}$, $acc(X_2) = g^{r_{X_2}(1+s)(2+s)}$, ${acc(X_1 - X_2)}^* = g^{r_{X_1}/r_{X_2}(1+s)}$
      \item \(
        \begin{aligned}[t]
          e(acc(X_2), {acc(X_1 - X_2)}^*) &= e(g^{r_{X_2}(1+s)(2+s)},g^{r_{X_1}/r_{X_2}(1+s)}) = {e(g, g)}^{r_{X_1}{(1+s)}^2(2+s)} \\
          e(acc(X_1), g) &=  e(g^{r_{X_1}{(1+s)}^2(2+s)}, g) = {e(g, g)}^{r_{X_1}{(1+s)}^2(2+s)}
        \end{aligned}
        \)
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}{PA$^2$ Protocols on Multiset Operations --- Sum}
  \begin{block}{$sum(\{X_1, \dotsc, X_n\})$: returns $acc$ value of $S = \uplus_{i=1}^n X_i$}
    \begin{itemize}
      \item DO prepares $acc(X_1), \dotsc, acc(X_n)$
      \item SP computes ${acc(\uplus_{j = 1}^i X_j)}^*$, for $i \in [2, n]$
      \item Client verifies
        \begin{adjustbox}{valign=t}
          \(
          \begin{aligned}
            \left \{
              \begin{array}{l}
                e(acc(X_1), acc(X_2)) \stackrel{?}{=} e({acc(X_1 \uplus X_2)}^*, g)\\
                e({acc(X_1\uplus X_2)}^*, acc(X_3)) \stackrel{?}{=} e({acc(X_1\uplus X_2\uplus X_3)}^*, g) \\
                \vdots\\
                e({acc(\uplus_{i=1}^{n-1} X_i)}^*, acc(X_n)) \stackrel{?}{=} e({acc(S)}^*, g)
              \end{array}
            \right.
          \end{aligned}
          \)
        \end{adjustbox}
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item $X_1 = \{ 1 \}$, $X_2 = \{ 1 \}$, $X_3 = \{ 2 \}$
      \item SP returns ${acc(X_1 \uplus X_2)}^* = acc(\{1, 1\})$ and ${acc(S)}^* = {acc(X_1 \uplus X_2 \uplus X_3)}^* = acc(\{1, 1, 2\})$
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}{PA$^2$ Protocols on Multiset Operations --- Empty}
  \begin{block}{$empty(\{X_1, \dotsc, X_n\})$: returns whether $\cap_{i=1}^n X_i = \emptyset$}
    \begin{itemize}
      \item DO prepares $acc(X_1), \dotsc, acc(X_n)$
      \item Based on \alert{extended Euclidean algorithm}
        \begin{align*}
          \textstyle%
          \cap \{ X_i \} = \emptyset \Rightarrow \exists Q_i \text{ s.t. } \sum_{i=1}^n Q_i \cdot P(X_i) = 1
        \end{align*}
      \item SP computes $F_i^* = g^{Q_i}$, for $i \in [1, n]$
      \item Client verifies $\prod_{i=1}^n e(acc(X_i), F_i^*) \stackrel{?}{=} e(g, g)$
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item $X_1 = \{ 1 \}$, $X_2 = \{ 2 \}$
      \item SP returns $F_1^* = g^{-1/r_{X_1}}$, $F_2^* = g^{1/r_{X_2}}$
      \item \(
        \begin{aligned}[t]
          e(acc(X_1), F_1^*)e(acc(X_2), F_2^*) &= e(g^{r_{X_1}(1+s)}, g^{-1/r_{X_1}})e(g^{r_{X_2}(2+s)}, g^{1/r_{X_2}}) \\
                                               &= {e(g,g)}^{-1-s}{e(g,g)}^{2+s} = {e(g,g)}^{-1-s+2+s} = e(g,g)
        \end{aligned}
        \)
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}{PA$^2$ Protocols on Multiset Operations --- Union}
  \begin{block}{$union(\{X_1, \dotsc, X_2\})$: returns $acc$ value of $U = \cup_{i=1}^n X_i$}
    \begin{itemize}
      \item Denote $\widehat{X}_i$ as the \alert{set version} of a multiset $X_i$.
      \item Client verifies two conditions:
        \begin{enumerate}
          \item \alert{Deflation checking} (no object is missing):
            \begin{align*}
              \widehat{X}_1 \subseteq U \wedge \widehat{X}_2 \subseteq U \wedge \cdots \widehat{X}_n \subseteq U
            \end{align*}
          \item \alert{Inflation checking} (no non-result object is added):
            \begin{align*}
              (U - \widehat{X}_1) \cap (U - \widehat{X}_2) \cap \cdots (U - \widehat{X}_n) = \emptyset
            \end{align*}
        \end{enumerate}
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item $X_1 = \{ 1 \}$, $X_2 = \{ 2 \}$, $U = \{ 1, 2 \}$
      \item \alert{Deflation checking}: $\{1\} \subseteq \{1,2\}, \{2\} \subseteq \{1,2\}$ \\
        \alert{Inflation checking}: $\{2\} \cap \{1\} = \emptyset$
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}{PA$^2$ Protocols on Multiset Operations --- Times}
  \begin{block}{$times(X, t)$: returns $acc$ value of $t \cdot X$}
    \begin{itemize}
      \item Let $d = \lfloor \log_2(t) \rfloor$ and $t = {(b_0b_1\cdots b_d)}_2$, the \alert{binary form} of $t$.
      \item $times(X, t) = sum(\{b_0 \cdot X, \dotsc, b_i \cdot 2^i \cdot X, \dotsc, b_d \cdot 2^d \cdot X\})$
      \item SP computes ${acc(2\cdot X)}^*, \dotsc, {acc({2^d} \cdot X)}^*, {acc(t \cdot X)}^*$
      \item Client verifies:
        \begin{itemize}
          \item $e({acc(2^{i-1} \cdot X)}^*, {acc(2^{i-1} \cdot X)}^*) = e({acc(2^{i} \cdot X)}^*, g)$, for $i \in [1, d]$
          \item Apply $sum(\{b_0 \cdot X, \dotsc, b_i \cdot 2^i \cdot X, \dotsc, b_d \cdot 2^d \cdot X\})$
        \end{itemize}
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item When $t = 5$, SP computes $acc(2\cdot X), acc(4\cdot X)$
      \item $acc(5 \cdot X) = sum(\{X, 4\cdot X\})$
    \end{itemize}
  \end{example}
\end{frame}

\subsubsection{PA$^2$ Algorithms on Aggregate Queries}

\begin{frame}{PA$^2$ Algorithms on Aggregate Queries --- Sum Query}
  \begin{block}{Sum Query $sum(x_q)$: returns feature $x_q$'s multiplicity sum $\eta_q$}
    \begin{itemize}
      \item Denote $X_1, \dotsc, X_n$ as input multisets and $R = \{ (x_q, \eta_q) \}$ as the result.
      \item Execute $sum(\{X_1, \dotsc, X_n\})$ to get verified $acc(S)$, where $S = \uplus \{X_i\}$
      \item Client verifies two conditions:
        \begin{enumerate}
          \item \alert{Inflation checking} (no non-result object is added):
            \begin{align*}
              R \subseteq S
            \end{align*}
          \item \alert{Deflation checking} (no object is missing):
            \begin{align*}
              (S - R) \cap R = \emptyset
            \end{align*}
        \end{enumerate}
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item $S = \{(a,6), (b, 1), (c, 5), (d, 3), (e, 2)\}$, $x_q = a$. The result is $R = \{(a, 6)\}$.
      \item \alert{Inflation checking}: $\{(a, 6)\} \subseteq \{(a,6)$, $(b, 1)$, $(c, 5)$, $(d, 3)$, $(e, 2)\}$ \\
        \alert{Deflation checking}: $\{(b, 1), (c,5), (d, 3), (e, 2)\} \cap \{(a, 6)\} = \emptyset$
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}{PA$^2$ Algorithms on Aggregate Queries --- Max Query}
  \begin{block}{Max Query: returns the feature with the highest (i.e., top-1) multiplicity}
    \begin{itemize}
      \item Denote $X_1, \dotsc, X_n$ as input multisets and $R = \{ (x, \tau) \}$ as the result.
      \item Execute $sum(\{X_1, \dotsc, X_n\})$ to get verified $acc(S)$, where $S = \uplus \{X_i\}$
      \item Execute $union(\{X_1, \dotsc, X_n\})$ to get verified $acc(U)$, where $U = \cup \{\widehat{X}_i\}$
      \item Client verifies three conditions:
        \begin{enumerate}
          \item \alert{Inflation checking}: $R \subseteq S$
          \item \alert{Deflation checking}: $(S - R) \cap R = \emptyset$
          \item \alert{Completeness checking} (all other features have multiplicity less than $\tau$):
            \begin{align*}
              (S - R) \subseteq \tau \cdot (U -\widehat{R})
            \end{align*}
        \end{enumerate}
    \end{itemize}
  \end{block}
  \begin{example}
    \begin{itemize}
      \item $S = \{(a,6), (b, 1), (c, 5), (d, 3), (e, 2)\}$, $U = \{(a, 1), (b, 1), (c, 1), (d, 1), (e, 1)\}$.
      \item The result is $R = \{(a, 6)\}$.
      \item \alert{Completeness checking}: $\{(b, 1), (c, 5), (d, 3), (e, 2)\} \subseteq $ $\{(b,$ $6), (c, 6), (d, 6), (e, 6)\}$
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}{PA$^2$ Algorithms on Aggregate Queries --- Other Queries}
  \begin{itemize}
    \item \textbf{Count Query}
      \begin{itemize}
        \item Returns the count of candidate objects that have the queried feature.
        \item Equivalent to \alert{Sum Query} with multiplicity of each feature enforced as 1.
      \end{itemize}
    \item \textbf{Average Query}
      \begin{itemize}
        \item Returns the average multiplicity of queried feature in the candidate objects.
        \item Equivalent to \alert{Sum Query} divided by \alert{Count Query}.
      \end{itemize}
    \item \textbf{Min Query}
      \begin{itemize}
        \item Returns the feature with the lowest (i.e. bottom-$1$) multiplicity.
        \item Similar to \alert{Max Query}, except $(S - R) \supseteq {\tau} \cdot (U - \widehat{R})$.
      \end{itemize}
    \item \textbf{Frequent Features Query}
      \begin{itemize}
        \item Returns the feature with multiplicity larger than threshold $\tau$.
        \item Sub module of \alert{Max Query}.
      \end{itemize}
    \item \textbf{Top-$k$ Query}
      \begin{itemize}
        \item Returns the features with the top-$k$ multiplicity.
        \item Similar to \alert{Max Query}, except $\tau$ is the $k$-th feature's multiplicity.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsubsection{PA$^2$ on Candidate Object Selection}

\subsection{Performance Evaluation}

\section{Authenticating Relational Queries with Fine-Grained Access Control}

\subsection{Problem Formulation}

\subsection{Solutions}

\subsection{Performance Evaluation}

\section{Authenticating {kNN} Queries in Distributed Settings}

\subsection{Problem Formulation}

\subsection{Solutions}

\subsection{Performance Evaluation}

\section{Conclusions}

\begin{frame}{Contributions}
\end{frame}

\begin{frame}{Future Directions}
\end{frame}

\begin{frame}[standout]
  Thanks \\
  Questions?
\end{frame}

\appendix%

\begingroup
\setbeamertemplate{frametitle continuation}{}
\begin{frame}[t,allowframebreaks]{\refname}
  \bookmark[page=\thepage,startatroot]{\refname}
  \setbeamertemplate{bibliography item}[text]
  \renewcommand*{\bibfont}{\scriptsize}
  \printbibliography[heading=none]%
\end{frame}
\endgroup

\end{document}
